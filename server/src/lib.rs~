#![allow(unused_parens)]
#![recursion_limit = "128"]
#![feature(proc_macro_hygiene, decl_macro)]
#[macro_use]
extern crate rocket;
#[macro_use]
extern crate rocket_contrib;
extern crate chrono;
extern crate config as config_rs;
extern crate uuid;
#[macro_use]
extern crate failure;
extern crate error_chain;
#[macro_use]
extern crate log;
extern crate bisetmap;
extern crate bitcoin;
extern crate cfg_if;
extern crate crypto;
extern crate hex;
extern crate jsonwebtoken as jwt;
extern crate log4rs;
extern crate rusoto_dynamodb;
extern crate serde_dynamodb;

extern crate curv;
extern crate electrumx_client;
extern crate kms;
extern crate monotree;
extern crate multi_party_ecdsa;
extern crate zk_paillier;

#[macro_use]
extern crate serde_derive;
extern crate serde;
extern crate serde_json;

#[cfg(test)]
#[macro_use]
extern crate serial_test;
#[cfg(test)]
extern crate floating_duration;
extern crate mockall;
#[cfg(test)]
extern crate mockito;

extern crate shared_lib;

pub mod config;
pub mod error;
pub mod protocol;
pub mod server;
pub mod storage;

pub type Result<T> = std::result::Result<T, error::SEError>;
pub type Hash = bitcoin::hashes::sha256d::Hash;

use rocket_contrib::databases::r2d2;
use rocket_contrib::databases::r2d2_postgres::PostgresConnectionManager;

use crate::protocol::transfer::TransferFinalizeData;
use crate::storage::db::Alpha;
use bitcoin::hashes::sha256d;
use bitcoin::Transaction;
use chrono::NaiveDateTime;
use curv::{BigInt, FE, GE};
use kms::ecdsa::two_party::*;
use mockall::predicate::*;
use mockall::*;
use multi_party_ecdsa::protocols::two_party_ecdsa::lindell_2017::party_one::Party1Private;
use multi_party_ecdsa::protocols::two_party_ecdsa::lindell_2017::{party_one, party_two};
use rocket_contrib::databases::postgres;
use shared_lib::{state_chain::*, structs::TransferMsg3, Root};
use std::collections::{HashMap, HashSet};
use uuid::Uuid;

#[database("postgres_w")]
pub struct DatabaseW(postgres::Connection);
#[database("postgres_r")]
pub struct DatabaseR(postgres::Connection);

/// Postgres database struct
pub struct PGDatabase {
    pub pool: Option<r2d2::Pool<PostgresConnectionManager>>
}

use structs::*;

#[automock]
pub trait Database {
    fn get_new() -> Self;
    fn set_connection_from_config(&mut self, config: &crate::config::Config) -> Result<()>;
    fn set_connection(&mut self, url: &String) -> Result<()>;
    fn from_pool(pool: r2d2::Pool<PostgresConnectionManager>) -> Self;
}

pub mod structs {
    use super::*;

    #[derive(Clone)]
    pub struct StateChainAmount {
        pub chain: StateChain,
        pub amount: i64,
    }

    pub struct TransferBatchData {
        pub state_chains: HashSet<Uuid>,
        pub punished_state_chains: Vec<Uuid>,
        pub start_time: NaiveDateTime,
        pub finalized: bool,
    }

    pub struct TransferFinalizeBatchData {
        pub finalized_data_vec: Vec<TransferFinalizeData>,
        pub start_time: NaiveDateTime,
    }

    #[derive(Debug)]
    pub struct StateChainOwner {
        pub locked_until: NaiveDateTime,
        pub owner_id: Uuid,
        pub chain: StateChain,
    }

    pub struct WithdrawConfirmData {
        pub tx_withdraw: Transaction,
        pub withdraw_sc_sig: StateChainSig,
        pub state_chain_id: Uuid,
    }

    pub struct TransferData {
        pub state_chain_id: Uuid,
        pub state_chain_sig: StateChainSig,
        pub x1: FE,
    }

    pub struct ECDSAKeypair {
        pub party_1_private: Party1Private,
        pub party_2_public: GE,
    }

    pub struct ECDSAFourthMessageInput {
        pub party_one_private: party_one::Party1Private,
        pub party_one_pdl_decommit: party_one::PDLdecommit,
        pub party_two_pdl_first_message: party_two::PDLFirstMessage,
        pub alpha: Alpha,
    }

    pub struct ECDSASignSecondInput {
        pub shared_key: MasterKey1,
        pub eph_ec_key_pair_party1: party_one::EphEcKeyPair,
        pub eph_key_gen_first_message_party_two: party_two::EphKeyGenFirstMsg,
    }

    pub struct ECDSAMasterKeyInput {
        pub party2_public: GE,
        pub paillier_key_pair: party_one::PaillierKeyPair,
        pub party_one_private: party_one::Party1Private,
        pub comm_witness: party_one::CommWitness,
    }
}
