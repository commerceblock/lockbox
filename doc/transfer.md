# Lockbox transfer functions

Lockbox operations to update private key share. Only `keyupdate_first` (called during transfer_receiver) and `keyupdate_second` (called during transfer_finalise) functions are called: `transfer_sender` does not involve the lockbox (the random transfer nonce `x1` is generated by the server). 

## Transfer structs

### Keyupdate first

```
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct KUSendMsg {        // Sent from server to lockbox
    pub user_id: Uuid,
    pub statechain_id: Uuid,
    pub x1: FE,
    pub t2: FE,
    pub o2_pub: GE,
}
```

```
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct KUReceiveMsg {      // Sent from lockbox back to server
    pub s2_pub: GE,
}
```

### Keyupdate second

```
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct KUFinalize {        // Sent from server to lockbox
    pub statechain_id: Uuid,
    pub shared_key_id: Uuid,
}
```

```
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct KUAttest {      // Sent from lockbox back to server
    pub statechain_id: Uuid,
    pub attestation: String,
}
```

## Function descriptions

``
fn keyupdate_first(&self, reciever_msg: KUSendMsg) -> Result<KUReceiveMsg>
``

The lockbox receives `user_id`, `statechain_id`, the (server generated) transfer nonce `x1`, transfer product `t2` and new owner public key share `o2_pub` from the server (in struct `KUSendMsg`). 

Then the following operations are performed:

```
    let s1 = self.database.get_private_keyshare(reciever_msg.user_id)?;

    let x1 = reciever_msg.x1;
    let t2 = reciever_msg.t2;

    // derive updated private key share
    let s2 = t2 * (x1.invert()) * s1;

    let g: GE = ECPoint::generator();
    let s2_pub = g * s2;

    let p1_pub = kp.party_2_public * s1;
    let p2_pub = reciever_msg.o2_pub * s2;

    // Check P1 = o1_pub*s1 === p2 = o2_pub*s2
    if p1_pub != p2_pub {
        error!("TRANSFER: Protocol failed. P1 != P2.");
        return Err(SEError::Generic(String::from(
            "Transfer protocol error: P1 != P2",
        )));
    }
```

The lockbox then saves `s2` in a local sealed database (references with `user_id`). The `ecdsa_keypair` for this user is not deleted yet (it will be at finalisation/keyupdate_second). 

The struct `KUReceiveMsg { theta, s2_pub }` is then returned to the server. 

```
fn keyupdate_second(&self, finalize_data: KUFinalize) -> Result<KUAttest>;
```

This function is called when the transfer is finalised. If `keyupdate_first` is run again (e.g. in case of failed batch), the same initial `s1` is used again to derive `s2` again. 

Once `keyupdate_second` is called, the initial `s1` must be deleted. The previously saved `s2` is then used as the active private keyshare (which will be used as `s1` in the next `keyupdate_first` for this utxo). 

